{"version":3,"file":"api.cjs.production.min.js","sources":["../src/platforms/vtex/clients/fetch.ts","../src/platforms/vtex/clients/commerce/index.ts","../src/platforms/vtex/clients/search/index.ts","../src/platforms/vtex/utils/errors.ts","../src/platforms/vtex/utils/enhanceSku.ts","../src/platforms/vtex/utils/slugify.ts","../src/platforms/vtex/resolvers/collection.ts","../src/platforms/vtex/resolvers/validateCart.ts","../src/platforms/vtex/resolvers/product.ts","../src/platforms/vtex/utils/facets.ts","../src/platforms/vtex/utils/sort.ts","../src/platforms/vtex/resolvers/query.ts","../src/platforms/vtex/index.ts","../src/platforms/vtex/resolvers/aggregateOffer.ts","../src/platforms/vtex/resolvers/seo.ts","../src/platforms/vtex/resolvers/facet.ts","../src/platforms/vtex/resolvers/facetValue.ts","../src/platforms/vtex/resolvers/offer.ts","../src/platforms/vtex/resolvers/aggregateRating.ts","../src/platforms/vtex/resolvers/review.ts","../src/platforms/vtex/resolvers/productGroup.ts","../src/platforms/vtex/resolvers/searchResult.ts","../src/platforms/vtex/resolvers/mutation.ts","../src/typeDefs/index.ts","../src/index.ts","../src/platforms/vtex/clients/index.ts","../src/platforms/vtex/loaders/index.ts","../src/platforms/vtex/loaders/sku.ts","../src/platforms/vtex/loaders/simulation.ts"],"sourcesContent":["import fetch from 'isomorphic-unfetch'\n\nexport const fetchAPI = async (info: RequestInfo, init?: RequestInit) => {\n  const response = await fetch(info, init)\n\n  if (response.ok) {\n    return response.json()\n  }\n\n  const text = await response.text()\n\n  throw new Error(text)\n}\n","import type { Context, Options } from '../../index'\nimport { fetchAPI } from '../fetch'\nimport type { Brand } from './types/Brand'\nimport type { CategoryTree } from './types/CategoryTree'\nimport type { OrderForm, OrderFormInputItem } from './types/OrderForm'\nimport type { PortalPagetype } from './types/Portal'\nimport type {\n  Simulation,\n  SimulationArgs,\n  SimulationOptions,\n} from './types/Simulation'\n\nconst BASE_INIT = {\n  method: 'POST',\n  headers: {\n    'content-type': 'application/json',\n  },\n}\n\nexport const VtexCommerce = (\n  { account, environment }: Options,\n  ctx: Context\n) => {\n  const base = `http://${account}.${environment}.com.br`\n\n  return {\n    catalog: {\n      brand: {\n        list: (): Promise<Brand[]> =>\n          fetchAPI(`${base}/api/catalog_system/pub/brand/list`),\n      },\n      category: {\n        tree: (depth = 3): Promise<CategoryTree[]> =>\n          fetchAPI(`${base}/api/catalog_system/pub/category/tree/${depth}`),\n      },\n      portal: {\n        pagetype: (slug: string): Promise<PortalPagetype> =>\n          fetchAPI(`${base}/api/catalog_system/pub/portal/pagetype/${slug}`),\n      },\n    },\n    checkout: {\n      simulation: (\n        args: SimulationArgs,\n        { salesChannel }: SimulationOptions = {\n          salesChannel: ctx.storage.channel,\n        }\n      ): Promise<Simulation> => {\n        const params = new URLSearchParams({\n          sc: salesChannel,\n        })\n\n        return fetchAPI(\n          `${base}/api/checkout/pub/orderForms/simulation?${params.toString()}`,\n          {\n            ...BASE_INIT,\n            body: JSON.stringify(args),\n          }\n        )\n      },\n      orderForm: ({\n        id,\n        refreshOutdatedData = true,\n        salesChannel = ctx.storage.channel,\n      }: {\n        id: string\n        refreshOutdatedData?: boolean\n        salesChannel?: string\n      }): Promise<OrderForm> => {\n        const params = new URLSearchParams({\n          refreshOutdatedData: refreshOutdatedData.toString(),\n          sc: salesChannel,\n        })\n\n        return fetchAPI(\n          `${base}/api/checkout/pub/orderForm/${id}?${params.toString()}`,\n          BASE_INIT\n        )\n      },\n      updateOrderFormItems: ({\n        id,\n        orderItems,\n        allowOutdatedData = 'paymentData',\n        salesChannel = ctx.storage.channel,\n      }: {\n        id: string\n        orderItems: OrderFormInputItem[]\n        allowOutdatedData?: 'paymentData'\n        salesChannel?: string\n      }): Promise<OrderForm> => {\n        const params = new URLSearchParams({\n          allowOutdatedData,\n          sc: salesChannel,\n        })\n\n        return fetchAPI(\n          `${base}/api/checkout/pub/orderForm/${id}/items?${params}`,\n          {\n            ...BASE_INIT,\n            body: JSON.stringify({ orderItems }),\n            method: 'PATCH',\n          }\n        )\n      },\n    },\n  }\n}\n","import type { Context, Options } from '../../index'\nimport { fetchAPI } from '../fetch'\nimport type { SelectedFacet } from '../../utils/facets'\nimport type { ProductSearchResult } from './types/ProductSearchResult'\nimport type { AttributeSearchResult } from './types/AttributeSearchResult'\n\nexport type Sort =\n  | 'price:desc'\n  | 'price:asc'\n  | 'orders:desc'\n  | 'name:desc'\n  | 'name:asc'\n  | 'release:desc'\n  | 'discount:desc'\n  | ''\n\nexport interface SearchArgs {\n  query?: string\n  page: number\n  count: number\n  type: 'product_search' | 'attribute_search'\n  sort?: Sort\n  selectedFacets?: SelectedFacet[]\n  fuzzy?: '0' | '1'\n}\n\nexport interface ProductLocator {\n  field: 'id' | 'slug'\n  value: string\n}\n\nexport const IntelligentSearch = (\n  { account, environment }: Options,\n  ctx: Context\n) => {\n  const base = `http://portal.${environment}.com.br/search-api/v1/${account}`\n  const policyFacet = { key: 'trade-policy', value: ctx.storage.channel }\n\n  const addDefaultFacets = (facets: SelectedFacet[]) => {\n    const facet = facets.find(({ key }) => key === policyFacet.key)\n\n    if (facet === undefined) {\n      return [...facets, policyFacet]\n    }\n\n    return facets\n  }\n\n  const search = <T>({\n    query = '',\n    page,\n    count,\n    sort = '',\n    selectedFacets = [],\n    type,\n    fuzzy = '0',\n  }: SearchArgs): Promise<T> => {\n    const params = new URLSearchParams({\n      page: (page + 1).toString(),\n      count: count.toString(),\n      query,\n      sort,\n      fuzzy,\n    })\n\n    const pathname = addDefaultFacets(selectedFacets)\n      .map(({ key, value }) => `${key}/${value}`)\n      .join('/')\n\n    return fetchAPI(\n      `${base}/api/split/${type}/${pathname}?${params.toString()}`\n    )\n  }\n\n  const products = (args: Omit<SearchArgs, 'type'>) =>\n    search<ProductSearchResult>({ ...args, type: 'product_search' })\n\n  const facets = (args: Omit<SearchArgs, 'type'>) =>\n    search<AttributeSearchResult>({ ...args, type: 'attribute_search' })\n\n  return {\n    facets,\n    products,\n  }\n}\n","export class BadRequestError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'BadRequestError'\n  }\n}\n\nexport class NotFoundError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'NotFoundError'\n  }\n}\n","import type { Product, Sku } from '../clients/search/types/ProductSearchResult'\n\nexport type EnhancedSku = Sku & { isVariantOf: Product }\n\nexport const enhanceSku = (sku: Sku, product: Product): EnhancedSku => ({\n  ...sku,\n  isVariantOf: product,\n})\n","import rawSlugify from '@sindresorhus/slugify'\n\nexport const slugify = (path: string) =>\n  rawSlugify(path, { separator: '-', lowercase: true })\n","import { slugify as baseSlugify } from '../utils/slugify'\nimport type { Resolver } from '..'\nimport type { Brand } from '../clients/commerce/types/Brand'\nimport type { CategoryTree } from '../clients/commerce/types/CategoryTree'\nimport type { PortalPagetype } from '../clients/commerce/types/Portal'\n\ntype Root = Brand | (CategoryTree & { level: number }) | PortalPagetype\n\nconst isBrand = (x: any): x is Brand => x.type === 'brand'\n\nconst isPortalPageType = (x: any): x is PortalPagetype =>\n  typeof x.pageType === 'string'\n\nconst slugify = (root: Root) => {\n  if (isBrand(root)) {\n    return baseSlugify(root.name)\n  }\n\n  if (isPortalPageType(root)) {\n    return new URL(`https://${root.url}`).pathname.slice(1)\n  }\n\n  return new URL(root.url).pathname.slice(1)\n}\n\nexport const StoreCollection: Record<string, Resolver<Root>> = {\n  id: ({ id }) => id.toString(),\n  slug: (root) => slugify(root),\n  seo: (root) =>\n    isBrand(root) || isPortalPageType(root)\n      ? {\n          title: root.title,\n          description: root.metaTagDescription,\n        }\n      : {\n          title: root.Title,\n          description: root.MetaTagDescription,\n        },\n  type: (root) =>\n    isBrand(root)\n      ? 'Brand'\n      : isPortalPageType(root)\n      ? root.pageType\n      : root.level === 0\n      ? 'Department'\n      : 'Category',\n  meta: (root) =>\n    isBrand(root)\n      ? {\n          selectedFacets: [{ key: 'brand', value: baseSlugify(root.name) }],\n        }\n      : {\n          selectedFacets: new URL(\n            isPortalPageType(root) ? `https://${root.url}` : root.url\n          ).pathname\n            .slice(1)\n            .split('/')\n            .map((segment, index) => ({\n              key: `category-${index + 1}`,\n              value: baseSlugify(segment),\n            })),\n        },\n  breadcrumbList: async (root, _, ctx) => {\n    const {\n      clients: { commerce },\n    } = ctx\n\n    const slug = slugify(root)\n\n    /**\n     * Split slug into segments so we fetch all data for\n     * the breadcrumb. For instance, if we get `/foo/bar`\n     * we need all metadata for both `/foo` and `/bar` and\n     * thus we need to fetch pageType for `/foo` and `/bar`\n     */\n    const segments = slug.split('/').filter((segment) => Boolean(segment))\n    const slugs = segments.map((__, index) =>\n      segments.slice(0, index + 1).join('/')\n    )\n\n    const pageTypes = await Promise.all(\n      slugs.map((s) => commerce.catalog.portal.pagetype(s))\n    )\n\n    return {\n      itemListElement: pageTypes.map((pageType, index) => ({\n        item: new URL(`https://${pageType.url}`).pathname,\n        name: pageType.name,\n        position: index + 1,\n      })),\n      numberOfItems: pageTypes.length,\n    }\n  },\n}\n","import deepEquals from 'fast-deep-equal'\n\nimport type { IStoreCart, IStoreOffer } from '../../../__generated__/schema'\nimport type {\n  OrderForm,\n  OrderFormItem,\n  OrderFormInputItem,\n} from '../clients/commerce/types/OrderForm'\nimport type { Context } from '..'\n\ntype Indexed<T> = T & { index?: number }\n\nconst getId = (item: IStoreOffer) =>\n  [item.itemOffered.sku, item.seller.identifier, item.price].join('::')\n\nconst orderFormItemToOffer = (\n  item: OrderFormItem,\n  index?: number\n): Indexed<IStoreOffer> => ({\n  listPrice: item.listPrice / 100,\n  price: item.sellingPrice / 100,\n  quantity: item.quantity,\n  seller: { identifier: item.seller },\n  itemOffered: {\n    sku: item.id,\n    image: [],\n    name: item.name,\n  },\n  index,\n})\n\nconst offerToOrderItemInput = (\n  offer: Indexed<IStoreOffer>\n): OrderFormInputItem => ({\n  quantity: offer.quantity,\n  seller: offer.seller.identifier,\n  id: offer.itemOffered.sku,\n  index: offer.index,\n})\n\nconst groupById = (offers: IStoreOffer[]): Map<string, IStoreOffer> =>\n  offers.reduce((acc, item) => {\n    const id = getId(item)\n\n    acc.set(id, acc.get(id) ?? item)\n\n    return acc\n  }, new Map<string, IStoreOffer>())\n\nconst equals = (of1: OrderForm, of2: OrderForm) => {\n  const pick = ({ orderFormId, messages, items, salesChannel }: OrderForm) => ({\n    orderFormId,\n    messages,\n    salesChannel,\n    items: items.map(\n      ({ uniqueId, quantity, seller, sellingPrice, availability }) => ({\n        uniqueId,\n        quantity,\n        seller,\n        sellingPrice,\n        availability,\n      })\n    ),\n  })\n\n  return deepEquals(pick(of1), pick(of2))\n}\n\n/**\n * This resolver implements the optimistic cart behavior. The main idea in here\n * is that we receive a cart from the UI (as query params) and we validate it with\n * the commerce platform. If the cart is valid, we return null, if the cart is\n * invalid according to the commerce platform, we return the new cart the UI should use\n * instead\n *\n * The algoritm is something like:\n * 1. Fetch orderForm from VTEX\n * 2. Compute delta changes between the orderForm and the UI's cart\n * 3. Update the orderForm in VTEX platform accordingly\n * 4. If any chages were made, send to the UI the new cart. Null otherwise\n */\nexport const validateCart = async (\n  _: unknown,\n  {\n    cart: {\n      order: { orderNumber, acceptedOffer },\n    },\n  }: { cart: IStoreCart },\n  ctx: Context\n) => {\n  const {\n    clients: { commerce },\n    loaders: { skuLoader },\n  } = ctx\n\n  // Step1: Get OrderForm from VTEX Commerce\n  const orderForm = await commerce.checkout.orderForm({\n    id: orderNumber,\n  })\n  console.log(orderForm, 'orderForm')\n  // Step2: Process items from both browser and checkout so they have the same shape\n  const browserItemsById = groupById(acceptedOffer)\n  const originItemsById = groupById(orderForm.items.map(orderFormItemToOffer))\n  const browserItems = Array.from(browserItemsById.values()) // items on the user's browser\n  const originItems = Array.from(originItemsById.values()) // items on the VTEX platform backend\n\n  // Step3: Compute delta changes\n  const { itemsToAdd, itemsToUpdate } = browserItems.reduce(\n    (acc, item) => {\n      const maybeOriginItem = originItemsById.get(getId(item))\n\n      if (!maybeOriginItem) {\n        acc.itemsToAdd.push(item)\n      } else {\n        acc.itemsToUpdate.push({\n          ...maybeOriginItem,\n          quantity: item.quantity,\n        })\n      }\n\n      return acc\n    },\n    {\n      itemsToAdd: [] as IStoreOffer[],\n      itemsToUpdate: [] as IStoreOffer[],\n    }\n  )\n\n  const itemsToDelete = originItems\n    .filter((item) => !browserItemsById.has(getId(item)))\n    .map((item) => ({ ...item, quantity: 0 }))\n\n  const changes = [...itemsToAdd, ...itemsToUpdate, ...itemsToDelete].map(\n    offerToOrderItemInput\n  )\n\n  if (changes.length === 0) {\n    return null\n  }\n\n  // Step4: Apply delta changes to order form\n  const updatedOrderForm = await commerce.checkout.updateOrderFormItems({\n    id: orderForm.orderFormId,\n    orderItems: changes,\n  })\n\n  // Step5: If no changes detected before/after updating orderForm, the order is validated\n  if (equals(orderForm, updatedOrderForm)) {\n    return null\n  }\n\n  // Step6: There were changes, convert orderForm to StoreOrder\n  return {\n    order: {\n      orderNumber: updatedOrderForm.orderFormId,\n      acceptedOffer: updatedOrderForm.items.map((item) => ({\n        ...item,\n        product: skuLoader.load([{ key: 'id', value: item.id }]), // TODO: add channel\n      })),\n    },\n    messages: updatedOrderForm.messages.map(({ text, status }) => ({\n      text,\n      status: status.toUpperCase(),\n    })),\n  }\n}\n","import type { Resolver } from '..'\nimport type { EnhancedSku } from '../utils/enhanceSku'\n\ntype Root = EnhancedSku\n\nconst DEFAULT_IMAGE = {\n  name: 'image',\n  value:\n    'https://storecomponents.vtexassets.com/assets/faststore/images/image___117a6d3e229a96ad0e0d0876352566e2.svg',\n}\n\nconst getSlug = (link: string, id: string) => `${link}-${id}`\nconst getPath = (link: string, id: string) => `/${getSlug(link, id)}/p`\nconst nonEmptyArray = <T>(array: T[] | null | undefined) =>\n  Array.isArray(array) && array.length > 0 ? array : null\n\nexport const StoreProduct: Record<string, Resolver<Root>> = {\n  productID: ({ id }) => id,\n  name: ({ isVariantOf, name }) => name ?? isVariantOf.name,\n  slug: ({ isVariantOf: { link }, id }) => getSlug(link, id),\n  description: ({ isVariantOf: { description } }) => description,\n  seo: ({ isVariantOf: { name, description } }) => ({\n    title: name,\n    description,\n  }),\n  brand: ({ isVariantOf: { brand } }) => ({ name: brand }),\n  breadcrumbList: ({ isVariantOf: { categoryTrees, name, link }, id }) => ({\n    itemListElement: [\n      ...categoryTrees.reverse().map(({ categoryNames }, index) => ({\n        name: categoryNames[categoryNames.length - 1],\n        item: `/${categoryNames.join('/').toLowerCase()}`,\n        position: index + 1,\n      })),\n      {\n        name,\n        item: getPath(link, id),\n        position: categoryTrees.length + 1,\n      },\n    ],\n    numberOfItems: categoryTrees.length,\n  }),\n  image: ({ isVariantOf, images }) =>\n    (\n      nonEmptyArray(images) ??\n      nonEmptyArray(isVariantOf.images) ?? [DEFAULT_IMAGE]\n    ).map(({ name, value }) => ({\n      alternateName: name ?? '',\n      url: value.replace('vteximg.com.br', 'vtexassets.com'),\n    })),\n  sku: ({\n    isVariantOf: {\n      skus: [sku],\n    },\n  }) => sku.id,\n  gtin: ({ reference }) => reference ?? '',\n  review: () => [],\n  aggregateRating: () => ({}),\n  offers: async (product, _, ctx) => {\n    const {\n      loaders: { simulationLoader },\n      storage: { channel },\n    } = ctx\n\n    const { id, policies } = product\n    const sellers = policies.find((policy) => policy.id === channel)?.sellers\n\n    if (sellers == null) {\n      // This error will likely happen when you forget to forward the channel somewhere in your code.\n      // Make sure all queries that lead to a product are forwarding the channel in context corectly\n      throw new Error(\n        `Product with id ${id} has no sellers for channel ${channel}.`\n      )\n    }\n\n    // Unique seller ids\n    const sellerIds = sellers.map((seller) => seller.id)\n    const items = Array.from(new Set(sellerIds)).map((seller) => ({\n      quantity: 1,\n      seller,\n      id,\n    }))\n\n    const simulation = await simulationLoader.load(items)\n\n    return { ...simulation, product }\n  },\n  isVariantOf: ({ isVariantOf }) => isVariantOf,\n}\n","import { BadRequestError } from './errors'\n\nexport interface SelectedFacet {\n  key: string\n  value: string\n}\n\nconst getIdFromSlug = (slug: string) => {\n  const id = slug.split('-').pop()\n\n  if (id == null) {\n    throw new BadRequestError('Error while extracting sku id from product slug')\n  }\n\n  return id\n}\n\n/**\n * Transform facets from the store to VTEX platform facets.\n * For instance, the channel in Store becames trade-policy in VTEX's realm\n * */\nexport const transformSelectedFacet = ({ key, value }: SelectedFacet) => {\n  switch (key) {\n    case 'channel':\n      return { key: 'trade-policy', value }\n\n    case 'slug':\n      return { key: 'id', value: getIdFromSlug(value) }\n\n    default:\n      return { key, value }\n  }\n}\n","export const SORT_MAP = {\n  price_desc: 'price:desc',\n  price_asc: 'price:asc',\n  orders_desc: 'orders:desc',\n  name_desc: 'name:desc',\n  name_asc: 'name:asc',\n  release_desc: 'release:desc',\n  discount_desc: 'discount:desc',\n  score_desc: '',\n} as const\n","import { enhanceSku } from '../utils/enhanceSku'\nimport { NotFoundError } from '../utils/errors'\nimport { transformSelectedFacet } from '../utils/facets'\nimport { SORT_MAP } from '../utils/sort'\nimport { StoreCollection } from './collection'\nimport type {\n  QueryProductArgs,\n  QueryAllCollectionsArgs,\n  QueryAllProductsArgs,\n  QuerySearchArgs,\n  QueryCollectionArgs,\n} from '../../../__generated__/schema'\nimport type { CategoryTree } from '../clients/commerce/types/CategoryTree'\nimport type { Context } from '../index'\n\nexport const Query = {\n  product: async (_: unknown, { locator }: QueryProductArgs, ctx: Context) => {\n    // Insert channel in context for later usage\n    ctx.storage = {\n      ...ctx.storage,\n      channel:\n        locator.find((facet) => facet.key === 'channel')?.value ??\n        ctx.storage.channel,\n    }\n\n    const {\n      loaders: { skuLoader },\n    } = ctx\n\n    return skuLoader.load(locator.map(transformSelectedFacet))\n  },\n  collection: async (\n    _: unknown,\n    { slug }: QueryCollectionArgs,\n    ctx: Context\n  ) => {\n    const {\n      clients: { commerce },\n    } = ctx\n\n    const result = await commerce.catalog.portal.pagetype(slug)\n\n    const whitelist = ['Brand', 'Category', 'Department', 'Subcategory']\n\n    if (whitelist.includes(result.pageType)) {\n      return result\n    }\n\n    throw new NotFoundError(`Not Found: ${slug}`)\n  },\n  search: async (\n    _: unknown,\n    { first, after: maybeAfter, sort, term, selectedFacets }: QuerySearchArgs,\n    ctx: Context\n  ) => {\n    // Insert channel in context for later usage\n    ctx.storage = {\n      ...ctx.storage,\n      channel:\n        selectedFacets?.find((facet) => facet.key === 'channel')?.value ??\n        ctx.storage.channel,\n    }\n\n    const after = maybeAfter ? Number(maybeAfter) : 0\n    const searchArgs = {\n      page: Math.ceil(after / first),\n      count: first,\n      query: term,\n      sort: SORT_MAP[sort ?? 'score_desc'],\n      selectedFacets: selectedFacets?.map(transformSelectedFacet) ?? [],\n    }\n\n    return searchArgs\n  },\n  allProducts: async (\n    _: unknown,\n    { first, after: maybeAfter }: QueryAllProductsArgs,\n    ctx: Context\n  ) => {\n    const {\n      clients: { search },\n    } = ctx\n\n    const after = maybeAfter ? Number(maybeAfter) : 0\n    const products = await search.products({\n      page: Math.ceil(after / first),\n      count: first,\n    })\n\n    const skus = products.products\n      .map((product) => product.skus.map((sku) => enhanceSku(sku, product)))\n      .flat()\n      .filter((sku) => sku.sellers.length > 0)\n\n    return {\n      pageInfo: {\n        hasNextPage: products.pagination.after.length > 0,\n        hasPreviousPage: products.pagination.before.length > 0,\n        startCursor: '0',\n        endCursor: products.total.toString(),\n        totalCount: products.total,\n      },\n      edges: skus.map((sku, index) => ({\n        node: sku,\n        cursor: (after + index).toString(),\n      })),\n    }\n  },\n  allCollections: async (\n    _: unknown,\n    __: QueryAllCollectionsArgs,\n    ctx: Context\n  ) => {\n    const {\n      clients: { commerce },\n    } = ctx\n\n    const [brands, tree] = await Promise.all([\n      commerce.catalog.brand.list(),\n      commerce.catalog.category.tree(),\n    ])\n\n    const categories: Array<CategoryTree & { level: number }> = []\n    const dfs = (node: CategoryTree, level: number) => {\n      categories.push({ ...node, level })\n\n      for (const child of node.children) {\n        dfs(child, level + 1)\n      }\n    }\n\n    for (const node of tree) {\n      dfs(node, 0)\n    }\n\n    const collections = [\n      ...brands.map((x) => ({ ...x, type: 'brand' })),\n      ...categories,\n    ]\n\n    return {\n      pageInfo: {\n        hasNextPage: false,\n        hasPreviousPage: false,\n        startCursor: '0',\n        endCursor: '0',\n      },\n      edges: collections\n        // Nullable slugs may cause one route to override the other\n        .filter((node) => Boolean(StoreCollection.slug(node, null, ctx, null)))\n        .map((node, index) => ({\n          node,\n          cursor: index.toString(),\n        })),\n    }\n  },\n}\n","import { getClients } from './clients'\nimport { getLoaders } from './loaders'\nimport { StoreAggregateOffer } from './resolvers/aggregateOffer'\nimport { StoreAggregateRating } from './resolvers/aggregateRating'\nimport { StoreCollection } from './resolvers/collection'\nimport { StoreFacet } from './resolvers/facet'\nimport { StoreFacetValue } from './resolvers/facetValue'\nimport { Mutation } from './resolvers/mutation'\nimport { StoreOffer } from './resolvers/offer'\nimport { StoreProduct } from './resolvers/product'\nimport { StoreProductGroup } from './resolvers/productGroup'\nimport { Query } from './resolvers/query'\nimport { StoreReview } from './resolvers/review'\nimport { StoreSearchResult } from './resolvers/searchResult'\nimport { StoreSeo } from './resolvers/seo'\nimport type { Loaders } from './loaders'\nimport type { Clients } from './clients'\n\nexport interface Options {\n  platform: 'vtex'\n  account: string\n  environment: 'vtexcommercestable' | 'vtexcommercebeta'\n  // Default sales channel to use for fetching products\n  channel: string\n}\n\nexport interface Context {\n  clients: Clients\n  loaders: Loaders\n  /**\n   * @description Storage updated at each request.\n   *\n   * Use this datastructure to store and share small values in the context.\n   * Use it with caution since dependecy injection leads to a more complex code\n   * */\n  storage: {\n    channel: string\n  }\n}\n\nexport type Resolver<R = unknown, A = unknown> = (\n  root: R,\n  args: A,\n  ctx: Context,\n  info: any\n) => any\n\nconst Resolvers = {\n  StoreCollection,\n  StoreAggregateOffer,\n  StoreProduct,\n  StoreSeo,\n  StoreFacet,\n  StoreFacetValue,\n  StoreOffer,\n  StoreAggregateRating,\n  StoreReview,\n  StoreProductGroup,\n  StoreSearchResult,\n  Query,\n  Mutation,\n}\n\nexport const getContextFactory = (options: Options) => (ctx: any) => {\n  ctx.storage = {\n    channel: options.channel,\n  }\n  ctx.clients = getClients(options, ctx)\n  ctx.loaders = getLoaders(options, ctx)\n\n  return ctx\n}\n\nexport const getResolvers = (_: Options) => Resolvers\n","import type { EnhancedSku } from '../utils/enhanceSku'\nimport type { Simulation } from '../clients/commerce/types/Simulation'\n\ntype Resolvers = (root: Simulation & { product: EnhancedSku }) => unknown\n\nexport const StoreAggregateOffer: Record<string, Resolvers> = {\n  highPrice: ({ items }) =>\n    items.reduce(\n      (acc, curr) => (acc > curr.sellingPrice ? acc : curr.sellingPrice),\n      items[0]?.sellingPrice ?? 0\n    ) / 1e2,\n  lowPrice: ({ items }) =>\n    items.reduce(\n      (acc, curr) => (acc < curr.sellingPrice ? acc : curr.sellingPrice),\n      items[0]?.sellingPrice ?? 0\n    ) / 1e2,\n  offerCount: ({ items }) => items.length,\n  priceCurrency: () => '',\n  offers: ({ items, product }) => items.map((item) => ({ ...item, product })),\n}\n","import type { Resolver } from '..'\n\ntype Root = { title?: string; description?: string }\n\nexport const StoreSeo: Record<string, Resolver<Root>> = {\n  title: ({ title }) => title ?? '',\n  description: ({ description }) => description ?? '',\n  titleTemplate: () => '',\n  canonical: () => '',\n}\n","import type { Resolver } from '..'\nimport type { Attribute } from '../clients/search/types/AttributeSearchResult'\n\ntype Root = Attribute\n\nexport const StoreFacet: Record<string, Resolver<Root>> = {\n  key: ({ key }) => key,\n  label: ({ label }) => label,\n  values: ({ values }) => values,\n  type: ({ type }) => (type === 'text' ? 'BOOLEAN' : 'RANGE'),\n}\n","import type { Resolver } from '..'\nimport type { Value } from '../clients/search/types/AttributeSearchResult'\n\ntype Root = Value\n\nexport const StoreFacetValue: Record<string, Resolver<Root>> = {\n  value: ({ key, from, to }) => key ?? `${from}-to-${to}`,\n  label: ({ label }) => label ?? 'unknown',\n  selected: ({ active }) => active,\n  quantity: ({ count }) => count,\n}\n","import type { EnhancedSku } from '../utils/enhanceSku'\nimport type { Resolver } from '..'\nimport type { Item } from '../clients/commerce/types/Simulation'\nimport type { OrderFormItem } from '../clients/commerce/types/OrderForm'\n\ntype Root =\n  | (Item & { product: EnhancedSku }) // when querying search/product\n  | (OrderFormItem & { product: Promise<EnhancedSku> }) // when querying order\n\nexport const StoreOffer: Record<string, Resolver<Root>> = {\n  priceCurrency: () => '',\n  priceValidUntil: ({ priceValidUntil }) => priceValidUntil ?? '',\n  itemCondition: () => 'https://schema.org/NewCondition',\n  availability: ({ availability }) =>\n    availability === 'available'\n      ? 'https://schema.org/InStock'\n      : 'https://schema.org/OutOfStock',\n  seller: ({ seller }) => ({\n    identifier: seller,\n  }),\n  price: ({ sellingPrice }) => sellingPrice / 1e2, // TODO add spot price calculation\n  sellingPrice: ({ sellingPrice }) => sellingPrice / 1e2,\n  listPrice: ({ listPrice }) => listPrice / 1e2,\n  itemOffered: ({ product }) => product,\n  quantity: ({ quantity }) => quantity,\n}\n","import type { Resolver } from '..'\n\n// TODO: Add a review system integration\nexport const StoreAggregateRating: Record<string, Resolver> = {\n  ratingValue: () => 5,\n  reviewCount: () => 0,\n}\n","import type { Resolver } from '..'\n\nexport const StoreReview: Record<string, Resolver> = {\n  reviewRating: () => ({\n    ratingValue: 5,\n    bestRating: 5,\n  }),\n  author: () => ({\n    name: '',\n  }),\n}\n","import { enhanceSku } from '../utils/enhanceSku'\nimport type { Product } from '../clients/search/types/ProductSearchResult'\nimport type { Resolver } from '..'\n\nexport const StoreProductGroup: Record<string, Resolver<Product>> = {\n  hasVariant: (root) => root.skus.map((sku) => enhanceSku(sku, root)),\n  productGroupID: ({ product }) => product,\n  name: ({ name }) => name,\n}\n","import { enhanceSku } from '../utils/enhanceSku'\nimport type { Resolver } from '..'\nimport type { SearchArgs } from '../clients/search'\n\ntype Root = Omit<SearchArgs, 'type'>\n\nexport const StoreSearchResult: Record<string, Resolver<Root>> = {\n  products: async (searchArgs, _, ctx) => {\n    const {\n      clients: { search },\n    } = ctx\n\n    const products = await search.products(searchArgs)\n\n    const skus = products.products\n      .map((product) => {\n        const maybeSku = product.skus.find((x) => x.sellers.length > 0)\n\n        return maybeSku && enhanceSku(maybeSku, product)\n      })\n      .filter((sku) => !!sku)\n\n    return {\n      pageInfo: {\n        hasNextPage: products.pagination.after.length > 0,\n        hasPreviousPage: products.pagination.before.length > 0,\n        startCursor: '0',\n        endCursor: products.total.toString(),\n        totalCount: products.total,\n      },\n      edges: skus.map((sku, index) => ({\n        node: sku,\n        cursor: index.toString(),\n      })),\n    }\n  },\n  facets: async (searchArgs, _, ctx) => {\n    const {\n      clients: { search: is },\n    } = ctx\n\n    const facets = await is.facets(searchArgs)\n\n    return facets.attributes ?? []\n  },\n}\n","import { validateCart } from './validateCart'\n\nexport const Mutation = {\n  validateCart,\n}\n","import { print } from 'graphql'\n\nimport AggregateOffer from './aggregateOffer.graphql'\nimport AggregateRating from './aggregateRating.graphql'\nimport Author from './author.graphql'\nimport Brand from './brand.graphql'\nimport Breadcrumb from './breadcrumb.graphql'\nimport Collection from './collection.graphql'\nimport Facet from './facet.graphql'\nimport Image from './image.graphql'\nimport Mutation from './mutation.graphql'\nimport Offer from './offer.graphql'\nimport Order from './order.graphql'\nimport Organization from './organization.graphql'\nimport PageInfo from './pageInfo.graphql'\nimport Product from './product.graphql'\nimport ProductGroup from './productGroup.graphql'\nimport Query from './query.graphql'\nimport Review from './review.graphql'\nimport Seo from './seo.graphql'\nimport Cart from './cart.graphql'\nimport Status from './status.graphql'\n\nexport const typeDefs = [\n  Query,\n  Mutation,\n  Brand,\n  Breadcrumb,\n  Collection,\n  Facet,\n  Image,\n  PageInfo,\n  Product,\n  Seo,\n  Offer,\n  AggregateRating,\n  Review,\n  Author,\n  ProductGroup,\n  Organization,\n  AggregateOffer,\n  Order,\n  Cart,\n  Status,\n]\n  .map(print)\n  .join('\\n')\n","import { makeExecutableSchema } from '@graphql-tools/schema'\n\nimport {\n  getContextFactory as getContextFactoryVTEX,\n  getResolvers as getResolversVTEX,\n} from './platforms/vtex'\nimport { typeDefs } from './typeDefs'\nimport type { Options as OptionsVTEX } from './platforms/vtex'\n\nexport * from './__generated__/schema'\n\nexport type Options = OptionsVTEX\n\nconst platforms = {\n  vtex: {\n    getResolvers: getResolversVTEX,\n    getContextFactory: getContextFactoryVTEX,\n  },\n}\n\nexport const getTypeDefs = () => typeDefs\n\nexport const getResolvers = (options: Options) =>\n  platforms[options.platform].getResolvers(options)\n\nexport const getContextFactory = (options: Options) =>\n  platforms[options.platform].getContextFactory(options)\n\nexport const getSchema = async (options: Options) =>\n  makeExecutableSchema({\n    resolvers: getResolvers(options),\n    typeDefs: getTypeDefs(),\n  })\n","import { VtexCommerce } from './commerce'\nimport { IntelligentSearch } from './search'\nimport type { Context, Options } from '..'\n\nexport type Clients = ReturnType<typeof getClients>\n\nexport const getClients = (options: Options, ctx: Context) => {\n  const search = IntelligentSearch(options, ctx)\n  const commerce = VtexCommerce(options, ctx)\n\n  return {\n    search,\n    commerce,\n  }\n}\n","import { getSimulationLoader } from './simulation'\nimport { getSkuLoader } from './sku'\nimport type { Context, Options } from '..'\n\nexport type Loaders = ReturnType<typeof getLoaders>\n\nexport const getLoaders = (options: Options, { clients }: Context) => {\n  const skuLoader = getSkuLoader(options, clients)\n  const simulationLoader = getSimulationLoader(options, clients)\n\n  return {\n    skuLoader,\n    simulationLoader,\n  }\n}\n","import DataLoader from 'dataloader'\n\nimport { BadRequestError } from '../utils/errors'\nimport { enhanceSku } from '../utils/enhanceSku'\nimport type { EnhancedSku } from '../utils/enhanceSku'\nimport type { Options } from '..'\nimport type { Clients } from '../clients'\nimport type { SelectedFacet } from '../utils/facets'\n\nexport const getSkuLoader = (_: Options, clients: Clients) => {\n  const loader = async (facetsList: readonly SelectedFacet[][]) => {\n    const skuIds = facetsList.map((facets) => {\n      const maybeFacet = facets.find(({ key }) => key === 'id')\n\n      if (!maybeFacet) {\n        throw new BadRequestError(\n          'Error while loading SKU. Needs to pass an id to selected facets'\n        )\n      }\n\n      return maybeFacet.value\n    })\n\n    const { products } = await clients.search.products({\n      query: `sku:${skuIds.join(';')}`,\n      page: 0,\n      count: skuIds.length,\n    })\n\n    const skuBySkuId = products.reduce((acc, product) => {\n      for (const sku of product.skus) {\n        acc[sku.id] = enhanceSku(sku, product)\n      }\n\n      return acc\n    }, {} as Record<string, EnhancedSku>)\n\n    const skus = skuIds.map((skuId) => skuBySkuId[skuId])\n    const missingSkus = skus.filter((sku) => !sku)\n\n    if (missingSkus.length > 0) {\n      throw new Error(\n        `Search API did not return the following skus: ${missingSkus.join(',')}`\n      )\n    }\n\n    return skus\n  }\n\n  return new DataLoader<SelectedFacet[], EnhancedSku>(loader, {\n    maxBatchSize: 99, // Max allowed batch size of Search API\n  })\n}\n","import DataLoader from 'dataloader'\n\nimport type {\n  PayloadItem,\n  Simulation,\n} from '../clients/commerce/types/Simulation'\nimport type { Options } from '..'\nimport type { Clients } from '../clients'\n\nexport const getSimulationLoader = (_: Options, clients: Clients) => {\n  const loader = async (allItems: readonly PayloadItem[][]) => {\n    const items = [...allItems.flat()]\n    const simulation = await clients.commerce.checkout.simulation({\n      items,\n    })\n\n    // Sort and filter simulation since Checkout API may return\n    // items that we didn't ask for\n    const simulated = simulation.items.reduce((acc, item) => {\n      const index = item.requestIndex\n\n      if (typeof index === 'number' && index < acc.length) {\n        acc[index] = item\n      }\n\n      return acc\n    }, Array(items.length).fill(null) as Simulation['items'])\n\n    const itemsIndices = allItems.reduce(\n      (acc, curr) => [...acc, curr.length + acc[acc.length - 1]],\n      [0]\n    )\n\n    return allItems.map((__, index) => ({\n      ...simulation,\n      items: simulated\n        .slice(itemsIndices[index], itemsIndices[index + 1])\n        .filter((item) => Boolean(item)),\n    }))\n  }\n\n  return new DataLoader<PayloadItem[], Simulation>(loader, {\n    maxBatchSize: 20,\n  })\n}\n"],"names":["fetchAPI","async","info","init","response","fetch","ok","json","text","Error","BASE_INIT","method","headers","IntelligentSearch","account","environment","ctx","base","policyFacet","key","value","storage","channel","search","query","page","count","sort","selectedFacets","type","fuzzy","params","URLSearchParams","toString","pathname","facets","undefined","find","map","join","args","products","BadRequestError","constructor","message","name","NotFoundError","enhanceSku","sku","product","isVariantOf","slugify","path","rawSlugify","separator","lowercase","isBrand","x","isPortalPageType","pageType","root","baseSlugify","URL","url","slice","StoreCollection","id","slug","seo","title","description","metaTagDescription","Title","MetaTagDescription","level","meta","split","segment","index","breadcrumbList","_","clients","commerce","segments","filter","Boolean","slugs","__","pageTypes","Promise","all","s","catalog","portal","pagetype","itemListElement","item","position","numberOfItems","length","getId","itemOffered","seller","identifier","price","orderFormItemToOffer","listPrice","sellingPrice","quantity","image","offerToOrderItemInput","offer","groupById","offers","reduce","acc","set","get","Map","DEFAULT_IMAGE","getSlug","link","getPath","nonEmptyArray","array","Array","isArray","getIdFromSlug","pop","transformSelectedFacet","SORT_MAP","price_desc","price_asc","orders_desc","name_desc","name_asc","release_desc","discount_desc","score_desc","Query","locator","facet","_locator$find","loaders","skuLoader","load","collection","result","includes","first","after","maybeAfter","term","_selectedFacets$find","Number","Math","ceil","allProducts","skus","flat","sellers","pageInfo","hasNextPage","pagination","hasPreviousPage","before","startCursor","endCursor","total","totalCount","edges","node","cursor","allCollections","brands","tree","brand","list","category","categories","dfs","push","child","children","Resolvers","StoreAggregateOffer","highPrice","items","curr","_items$","lowPrice","_items$2","offerCount","priceCurrency","StoreProduct","productID","categoryTrees","reverse","categoryNames","toLowerCase","images","alternateName","replace","gtin","reference","review","aggregateRating","simulationLoader","policies","policy","_policies$find","sellerIds","from","Set","StoreSeo","titleTemplate","canonical","StoreFacet","label","values","StoreFacetValue","to","selected","active","StoreOffer","priceValidUntil","itemCondition","availability","StoreAggregateRating","ratingValue","reviewCount","StoreReview","reviewRating","bestRating","author","StoreProductGroup","hasVariant","productGroupID","StoreSearchResult","searchArgs","maybeSku","is","attributes","Mutation","validateCart","cart","order","orderNumber","acceptedOffer","orderForm","checkout","console","log","browserItemsById","originItemsById","browserItems","originItems","itemsToAdd","itemsToUpdate","maybeOriginItem","changes","has","updatedOrderForm","updateOrderFormItems","orderFormId","orderItems","of1","of2","pick","messages","salesChannel","uniqueId","deepEquals","equals","status","toUpperCase","typeDefs","Brand","Breadcrumb","Collection","Facet","Image","PageInfo","Product","Seo","Offer","AggregateRating","Review","Author","ProductGroup","Organization","AggregateOffer","Order","Cart","Status","print","platforms","vtex","getResolvers","getContextFactory","options","depth","simulation","sc","body","JSON","stringify","refreshOutdatedData","allowOutdatedData","VtexCommerce","getClients","DataLoader","skuIds","facetsList","maybeFacet","skuBySkuId","skuId","missingSkus","maxBatchSize","getSkuLoader","allItems","simulated","requestIndex","fill","itemsIndices","getSimulationLoader","getLoaders","getTypeDefs","platform","makeExecutableSchema","resolvers"],"mappings":"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"}